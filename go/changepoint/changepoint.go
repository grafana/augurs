// Code generated by arcjet-gravity; DO NOT EDIT.

package changepoint

import "context"
import "errors"
import "github.com/tetratelabs/wazero"
import "github.com/tetratelabs/wazero/api"
import "reflect"

import _ "embed"

//go:embed changepoint.wasm
var wasmFileChangepoint []byte

// Types used by the changepoint detector world.
type IChangepointTypes interface {}

// The indices of the most likely changepoints.
type Output = []uint32

// The parameters for the logistic hazard function.
//
// Any unset parameters will use the default values.
type LogisticHazard struct {
	// Logit scaled, scaling factor for the logistic hazard function.
	//
	// Increasing increases hazard over the whole space; more negative numbers
	// result in larger run lengths.
	//
	// Defaults to -5.0.
	H *float64

	// Scale term. Roughly, the slope of the logistic hazard function.
	//
	// Higher numbers increase the variance of run-lengths.
	//
	// Defaults to 1.0.
	A *float64

	// Translation term (increasing moves the logistic to the left).
	//
	// Defaults to 1.0.
	B *float64
}

// The parameters for the Autoregressive Gaussian Process Changepoint Detection (Argpcp) algorithm.
//
// Any unset parameters will use the default values.
type ArgpcpParams struct {
	// The value of the constant kernel.
	ConstantValue *float64

	// The length scale of the RBF kernel.
	LengthScale *float64

	// The noise level of the white kernel.
	NoiseLevel *float64

	// The maximum autoregressive lag.
	MaxLag *uint32

	// The scale Gamma distribution alpha parameter.
	Alpha0 *float64

	// The scale Gamma distribution beta parameter.
	Beta0 *float64

	// The logistic hazard function parameters.
	LogisticHazard LogisticHazard
}

// The parameters for the Normal Gamma prior.
//
// Any unset parameters will use the default values.
type NormalGammaParams struct {
	// The prior mean.
	//
	// Defaults to 0.0.
	Mu *float64

	// The relative precision of Î¼ versus data.
	//
	// Defaults to 1.0.
	Rho *float64

	// The mean of rho (the precision) is v/s.
	//
	// Defaults to 1.0.
	S *float64

	// The degrees of freedom of precision of rho.
	//
	// Defaults to 1.0.
	V *float64
}

// The parameters for the Bayesian Online Changepoint Detection (BOCPD) algorithm.
//
// Any unset parameters will use the default values.
type BocpdParams struct {
	// The hazard lambda.
	//
	// `1/hazard` is the probability of the next step being a changepoint.
	// Therefore, the larger the value, the lower the prior probability
	// is for the any point to be a change-point.
	// Mean run-length is lambda - 1.
	//
	// Defaults to 250.0.
	HazardLambda *float64

	// The parameters of the Normal Gamma prior.
	NormalGammaParams *NormalGammaParams
}

// A changepoint detection algorithm.
type Algorithm interface {
	isAlgorithm()
}

// The Autoregressive Gaussian Process Changepoint Detection (Argpcp) algorithm.
type AlgorithmArgpcp ArgpcpParams
func (AlgorithmArgpcp) isAlgorithm() {}

// The Bayesian Online Changepoint Detection (BOCPD) algorithm.
//
// The algorithm is created with a Normal Gamma prior. Other priors
// are not yet supported.
type AlgorithmBocpd BocpdParams
func (AlgorithmBocpd) isAlgorithm() {}

// The input to changepoint detection.
type Input struct {
	// The data to detect changepoints in.
	Data []float64

	// The algorithm to use.
	Algorithm Algorithm
}

type ChangepointFactory struct {
	runtime wazero.Runtime
	module wazero.CompiledModule
}

func NewChangepointFactory(
	ctx context.Context,
	types IChangepointTypes,
) (*ChangepointFactory, error) {
	wazeroRuntime := wazero.NewRuntime(ctx)

	// Instantiate import host modules
	_, err0 := wazeroRuntime.NewHostModuleBuilder("grafana:augurs/types").
	Instantiate(ctx)
	if err0 != nil {
		return nil, err0
	}

	// Compiling the module takes a LONG time, so we want to do it once and hold
	// onto it with the Runtime
	module, err := wazeroRuntime.CompileModule(ctx, wasmFileChangepoint)
	if err != nil {
		return nil, err
	}
	return &ChangepointFactory{
		runtime: wazeroRuntime,
		module: module,
	}, nil
}

func (f *ChangepointFactory) Instantiate(ctx context.Context) (*ChangepointInstance, error) {
	if module, err := f.runtime.InstantiateModule(ctx, f.module, wazero.NewModuleConfig()); err != nil {
		return nil, err
	} else {
		return &ChangepointInstance{module}, nil
	}
}

func (f *ChangepointFactory) Close(ctx context.Context) {
	f.runtime.Close(ctx)
}

type ChangepointInstance struct {
	module api.Module
}

func (i *ChangepointInstance) Close(ctx context.Context) error {
	if err := i.module.Close(ctx); err != nil {
		return err
	}

	return nil
}

// writeString will put a Go string into the Wasm memory following the Component
// Model calling convetions, such as allocating memory with the realloc function
func writeString(
	ctx context.Context,
	s string,
	memory api.Memory,
	realloc api.Function,
) (uint64, uint64, error) {
	if len(s) == 0 {
		return 1, 0, nil
	}

	results, err := realloc.Call(ctx, 0, 0, 1, uint64(len(s)))
	if err != nil {
		return 1, 0, err
	}
	ptr := results[0]
	ok := memory.Write(uint32(ptr), []byte(s))
	if !ok {
		return 1, 0, err
	}
	return uint64(ptr), uint64(len(s)), nil
}

func (i *ChangepointInstance) Detect(
	ctx context.Context,
	input Input,
) (Output, error) {
	arg0 := input
	// Malloc { realloc: "cabi_realloc", size: (144+2*ptrsz), align: 8 }
	result0, err0 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 8, 152)
	if err0 != nil {
		var default0 Output
		return default0, err0
	}
	ptr0 := result0[0]
	// GetArg { nth: 0 }
	// RecordLower { record: Record { fields: [Field { name: "data", ty: Id(Id { idx: 9 }), docs: Docs { contents: Some("The data to detect changepoints in.") } }, Field { name: "algorithm", ty: Id(Id { idx: 8 }), docs: Docs { contents: Some("The algorithm to use.") } }] }, name: "input", ty: Id { idx: 10 } }
	data1 := arg0.Data
	algorithm1 := arg0.Algorithm
	// ListLower { element: F64, realloc: Some("cabi_realloc") }
	vec3 := data1
	len3 := uint64(len(vec3))
	result3, err3 := i.module.ExportedFunction("cabi_realloc").Call(ctx, 0, 0, 8, len3 * 8)
	if err3 != nil {
		var default3 Output
		return default3, err3
	}
	ptr3 := result3[0]
	for idx := uint64(0); idx < len3; idx++ {
		e := vec3[idx]
		base := uint32(ptr3 + uint64(idx) * uint64(8))
		// IterElem { element: F64 }
		// IterBasePointer
		// CoreF64FromF64
		result2 := api.EncodeF64(float64(e))
		// F64Store { offset: 0 }
		i.module.Memory().WriteUint64Le(uint32(base+0), result2)
	}
	// LengthStore { offset: ptrsz }
	i.module.Memory().WriteUint32Le(uint32(ptr0+4), uint32(len3))
	// PointerStore { offset: 0 }
	i.module.Memory().WriteUint32Le(uint32(ptr0+0), uint32(ptr3))
	// VariantLower { variant: Variant { cases: [Case { name: "argpcp", ty: Some(Id(Id { idx: 4 })), docs: Docs { contents: Some("The Autoregressive Gaussian Process Changepoint Detection (Argpcp) algorithm.") } }, Case { name: "bocpd", ty: Some(Id(Id { idx: 7 })), docs: Docs { contents: Some("The Bayesian Online Changepoint Detection (BOCPD) algorithm.\n\nThe algorithm is created with a Normal Gamma prior. Other priors\nare not yet supported.") } }] }, name: "algorithm", ty: Id { idx: 8 }, results: [] }
	switch variantPayload := algorithm1.(type) {
		case AlgorithmArgpcp:
			// VariantPayloadName
			// I32Const { val: 0 }
			// I32Store8 { offset: (2*ptrsz) }
			i.module.Memory().WriteByte(uint32(ptr0+8), 0)
			// RecordLower { record: Record { fields: [Field { name: "constant-value", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The value of the constant kernel.") } }, Field { name: "length-scale", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The length scale of the RBF kernel.") } }, Field { name: "noise-level", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The noise level of the white kernel.") } }, Field { name: "max-lag", ty: Id(Id { idx: 3 }), docs: Docs { contents: Some("The maximum autoregressive lag.") } }, Field { name: "alpha0", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The scale Gamma distribution alpha parameter.") } }, Field { name: "beta0", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The scale Gamma distribution beta parameter.") } }, Field { name: "logistic-hazard", ty: Id(Id { idx: 2 }), docs: Docs { contents: Some("The logistic hazard function parameters.") } }] }, name: "argpcp-params", ty: Id { idx: 4 } }
			constantValue4 := variantPayload.ConstantValue
			lengthScale4 := variantPayload.LengthScale
			noiseLevel4 := variantPayload.NoiseLevel
			maxLag4 := variantPayload.MaxLag
			alpha04 := variantPayload.Alpha0
			beta04 := variantPayload.Beta0
			logisticHazard4 := variantPayload.LogisticHazard
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(constantValue4).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (8+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+16), 0)
			} else {
				variantPayload := *constantValue4
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (8+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+16), 1)
				// CoreF64FromF64
				result5 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (16+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+24), result5)
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(lengthScale4).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (24+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+32), 0)
			} else {
				variantPayload := *lengthScale4
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (24+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+32), 1)
				// CoreF64FromF64
				result7 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (32+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+40), result7)
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(noiseLevel4).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (40+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+48), 0)
			} else {
				variantPayload := *noiseLevel4
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (40+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+48), 1)
				// CoreF64FromF64
				result9 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (48+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+56), result9)
			}
			// OptionLower { payload: U32, ty: Id { idx: 3 }, results: [] }
			if reflect.ValueOf(maxLag4).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (56+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+64), 0)
			} else {
				variantPayload := *maxLag4
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (56+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+64), 1)
				// I32FromU32
				result11 := api.EncodeU32(variantPayload)
				// I32Store { offset: (60+2*ptrsz) }
				i.module.Memory().WriteUint32Le(uint32(ptr0+68), uint32(result11))
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(alpha04).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (64+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+72), 0)
			} else {
				variantPayload := *alpha04
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (64+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+72), 1)
				// CoreF64FromF64
				result13 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (72+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+80), result13)
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(beta04).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (80+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+88), 0)
			} else {
				variantPayload := *beta04
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (80+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+88), 1)
				// CoreF64FromF64
				result15 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (88+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+96), result15)
			}
			// RecordLower { record: Record { fields: [Field { name: "h", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("Logit scaled, scaling factor for the logistic hazard function.\n\nIncreasing increases hazard over the whole space; more negative numbers\nresult in larger run lengths.\n\nDefaults to -5.0.") } }, Field { name: "a", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("Scale term. Roughly, the slope of the logistic hazard function.\n\nHigher numbers increase the variance of run-lengths.\n\nDefaults to 1.0.") } }, Field { name: "b", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("Translation term (increasing moves the logistic to the left).\n\nDefaults to 1.0.") } }] }, name: "logistic-hazard", ty: Id { idx: 2 } }
			h17 := logisticHazard4.H
			a17 := logisticHazard4.A
			b17 := logisticHazard4.B
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(h17).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (96+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+104), 0)
			} else {
				variantPayload := *h17
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (96+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+104), 1)
				// CoreF64FromF64
				result18 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (104+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+112), result18)
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(a17).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (112+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+120), 0)
			} else {
				variantPayload := *a17
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (112+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+120), 1)
				// CoreF64FromF64
				result20 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (120+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+128), result20)
			}
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(b17).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (128+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+136), 0)
			} else {
				variantPayload := *b17
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (128+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+136), 1)
				// CoreF64FromF64
				result22 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (136+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+144), result22)
			}
		case AlgorithmBocpd:
			// VariantPayloadName
			// I32Const { val: 1 }
			// I32Store8 { offset: (2*ptrsz) }
			i.module.Memory().WriteByte(uint32(ptr0+8), 1)
			// RecordLower { record: Record { fields: [Field { name: "hazard-lambda", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The hazard lambda.\n\n`1/hazard` is the probability of the next step being a changepoint.\nTherefore, the larger the value, the lower the prior probability\nis for the any point to be a change-point.\nMean run-length is lambda - 1.\n\nDefaults to 250.0.") } }, Field { name: "normal-gamma-params", ty: Id(Id { idx: 6 }), docs: Docs { contents: Some("The parameters of the Normal Gamma prior.") } }] }, name: "bocpd-params", ty: Id { idx: 7 } }
			hazardLambda24 := variantPayload.HazardLambda
			normalGammaParams24 := variantPayload.NormalGammaParams
			// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
			if reflect.ValueOf(hazardLambda24).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (8+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+16), 0)
			} else {
				variantPayload := *hazardLambda24
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (8+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+16), 1)
				// CoreF64FromF64
				result25 := api.EncodeF64(float64(variantPayload))
				// F64Store { offset: (16+2*ptrsz) }
				i.module.Memory().WriteUint64Le(uint32(ptr0+24), result25)
			}
			// OptionLower { payload: Id(Id { idx: 5 }), ty: Id { idx: 6 }, results: [] }
			if reflect.ValueOf(normalGammaParams24).IsZero() {
				// VariantPayloadName
				// I32Const { val: 0 }
				// I32Store8 { offset: (24+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+32), 0)
			} else {
				variantPayload := *normalGammaParams24
				// VariantPayloadName
				// I32Const { val: 1 }
				// I32Store8 { offset: (24+2*ptrsz) }
				i.module.Memory().WriteByte(uint32(ptr0+32), 1)
				// RecordLower { record: Record { fields: [Field { name: "mu", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The prior mean.\n\nDefaults to 0.0.") } }, Field { name: "rho", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The relative precision of Î¼ versus data.\n\nDefaults to 1.0.") } }, Field { name: "s", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The mean of rho (the precision) is v/s.\n\nDefaults to 1.0.") } }, Field { name: "v", ty: Id(Id { idx: 1 }), docs: Docs { contents: Some("The degrees of freedom of precision of rho.\n\nDefaults to 1.0.") } }] }, name: "normal-gamma-params", ty: Id { idx: 5 } }
				mu27 := variantPayload.Mu
				rho27 := variantPayload.Rho
				s27 := variantPayload.S
				v27 := variantPayload.V
				// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
				if reflect.ValueOf(mu27).IsZero() {
					// VariantPayloadName
					// I32Const { val: 0 }
					// I32Store8 { offset: (32+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+40), 0)
				} else {
					variantPayload := *mu27
					// VariantPayloadName
					// I32Const { val: 1 }
					// I32Store8 { offset: (32+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+40), 1)
					// CoreF64FromF64
					result28 := api.EncodeF64(float64(variantPayload))
					// F64Store { offset: (40+2*ptrsz) }
					i.module.Memory().WriteUint64Le(uint32(ptr0+48), result28)
				}
				// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
				if reflect.ValueOf(rho27).IsZero() {
					// VariantPayloadName
					// I32Const { val: 0 }
					// I32Store8 { offset: (48+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+56), 0)
				} else {
					variantPayload := *rho27
					// VariantPayloadName
					// I32Const { val: 1 }
					// I32Store8 { offset: (48+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+56), 1)
					// CoreF64FromF64
					result30 := api.EncodeF64(float64(variantPayload))
					// F64Store { offset: (56+2*ptrsz) }
					i.module.Memory().WriteUint64Le(uint32(ptr0+64), result30)
				}
				// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
				if reflect.ValueOf(s27).IsZero() {
					// VariantPayloadName
					// I32Const { val: 0 }
					// I32Store8 { offset: (64+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+72), 0)
				} else {
					variantPayload := *s27
					// VariantPayloadName
					// I32Const { val: 1 }
					// I32Store8 { offset: (64+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+72), 1)
					// CoreF64FromF64
					result32 := api.EncodeF64(float64(variantPayload))
					// F64Store { offset: (72+2*ptrsz) }
					i.module.Memory().WriteUint64Le(uint32(ptr0+80), result32)
				}
				// OptionLower { payload: F64, ty: Id { idx: 1 }, results: [] }
				if reflect.ValueOf(v27).IsZero() {
					// VariantPayloadName
					// I32Const { val: 0 }
					// I32Store8 { offset: (80+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+88), 0)
				} else {
					variantPayload := *v27
					// VariantPayloadName
					// I32Const { val: 1 }
					// I32Store8 { offset: (80+2*ptrsz) }
					i.module.Memory().WriteByte(uint32(ptr0+88), 1)
					// CoreF64FromF64
					result34 := api.EncodeF64(float64(variantPayload))
					// F64Store { offset: (88+2*ptrsz) }
					i.module.Memory().WriteUint64Le(uint32(ptr0+96), result34)
				}
			}
		default:
			var default37 Output
			return default37, errors.New("invalid variant type provided")
	}
	// CallWasm { name: "detect", sig: WasmSignature { params: [Pointer], results: [Pointer], indirect_params: true, retptr: true } }
	raw38, err38 := i.module.ExportedFunction("detect").Call(ctx, uint64(ptr0))
	if err38 != nil {
		var default38 Output
		return default38, err38
	}

	// The cleanup via `cabi_post_*` cleans up the memory in the guest. By
	// deferring this, we ensure that no memory is corrupted before the function
	// is done accessing it.
	defer func() {
		if _, err := i.module.ExportedFunction("cabi_post_detect").Call(ctx, raw38...); err != nil {
			// If we get an error during cleanup, something really bad is
			// going on, so we panic. Also, you can't return the error from
			// the `defer`
			panic(errors.New("failed to cleanup"))
		}
	}()

	results38 := raw38[0]
	// I32Load8U { offset: 0 }
	value39, ok39 := i.module.Memory().ReadByte(uint32(results38 + 0))
	if !ok39 {
		var default39 Output
		return default39, errors.New("failed to read byte from memory")
	}
	// ResultLift { result: Result_ { ok: Some(Id(Id { idx: 12 })), err: Some(String) }, ty: Id { idx: 13 } }
	var value48 Output
	var err48 error
	switch value39 {
	case 0:
		// PointerLoad { offset: ptrsz }
		ptr40, ok40 := i.module.Memory().ReadUint32Le(uint32(results38 + 4))
		if !ok40 {
			var default40 Output
			return default40, errors.New("failed to read pointer from memory")
		}
		// LengthLoad { offset: (2*ptrsz) }
		len41, ok41 := i.module.Memory().ReadUint32Le(uint32(results38 + 8))
		if !ok41 {
			var default41 Output
			return default41, errors.New("failed to read length from memory")
		}
		// ListLift { element: U32, ty: Id { idx: 0 } }
		base44 := ptr40
		len44 := len41
		result44 := make([]uint32, len44)
		for idx44 := uint32(0); idx44 < len44; idx44++ {
			base := base44 + idx44 * 4
			// IterBasePointer
			// I32Load { offset: 0 }
			value42, ok42 := i.module.Memory().ReadUint32Le(uint32(base + 0))
			if !ok42 {
				var default42 Output
				return default42, errors.New("failed to read i32 from memory")
			}
			// U32FromI32
			result43 := api.DecodeU32(uint64(value42))
			result44[idx44] = result43
		}
		value48 = result44
	case 1:
		// PointerLoad { offset: ptrsz }
		ptr45, ok45 := i.module.Memory().ReadUint32Le(uint32(results38 + 4))
		if !ok45 {
			var default45 Output
			return default45, errors.New("failed to read pointer from memory")
		}
		// LengthLoad { offset: (2*ptrsz) }
		len46, ok46 := i.module.Memory().ReadUint32Le(uint32(results38 + 8))
		if !ok46 {
			var default46 Output
			return default46, errors.New("failed to read length from memory")
		}
		// StringLift
		buf47, ok47 := i.module.Memory().Read(ptr45, len46)
		if !ok47 {
			var default47 Output
			return default47, errors.New("failed to read bytes from memory")
		}
		str47 := string(buf47)
		err48 = errors.New(str47)
	default:
		err48 = errors.New("invalid variant discriminant for expected")
	}
	// Flush { amt: 1 }
	// Return { amt: 1, func: Function { name: "detect", kind: Freestanding, params: [("input", Id(Id { idx: 11 }))], result: Some(Id(Id { idx: 13 })), docs: Docs { contents: Some("Detect changepoints in the input.") }, stability: Unknown } }
	return value48, err48
}

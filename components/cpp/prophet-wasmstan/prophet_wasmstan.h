// Generated by `wit-bindgen` 0.34.0. DO NOT EDIT!
#ifndef __BINDINGS_PROPHET_WASMSTAN_H
#define __BINDINGS_PROPHET_WASMSTAN_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

typedef struct prophet_wasmstan_string_t {
  uint8_t*ptr;
  size_t len;
} prophet_wasmstan_string_t;

typedef struct {
  double *ptr;
  size_t len;
} prophet_wasmstan_list_f64_t;

// The initial parameters for the optimization.
typedef struct augurs_prophet_wasmstan_types_inits_t {
  // Base trend growth rate.
  double   k;
  // Trend offset.
  double   m;
  // Trend rate adjustments, length s in data.
  prophet_wasmstan_list_f64_t   delta;
  // Regressor coefficients, length k in data.
  prophet_wasmstan_list_f64_t   beta;
  // Observation noise.
  double   sigma_obs;
} augurs_prophet_wasmstan_types_inits_t;

// The type of trend to use.
typedef uint8_t augurs_prophet_wasmstan_types_trend_indicator_t;

// Linear trend (default).
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_LINEAR 0
// 0
// Logistic trend.
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_LOGISTIC 1
// 1
// Flat trend.
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_FLAT 2

// Currently unused, we expect data to be passed as
// JSON instead, as in cmdstan invocations.
// /// Data for the Prophet model.
// record data {
// /// Number of time periods.
// /// This is `T` in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// n: s32,
// /// Time series, length n.
// y: list<f64>,
// /// Time, length n.
// t: list<f64>,
// /// Capacities for logistic trend, length n.
// cap: list<f64>,
// /// Number of changepoints.
// /// This is 'S' in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// s: s32,
// /// Times of trend changepoints, length s.
// t-change: list<f64>,
// /// The type of trend to use.
// trend-indicator: trend-indicator,
// /// Number of regressors.
// /// Must be greater than or equal to 1.
// /// This is `K` in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// k: s32,
// /// Indicator of additive features, length k.
// /// This is `s_a` in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// s-a: list<s32>,
// /// Indicator of multiplicative features, length k.
// /// This is `s_m` in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// s-m: list<s32>,
// /// Regressors.
// /// This is `X` in the Prophet STAN model definition,
// /// but WIT identifiers must be lower kebab-case.
// /// This is passed as a flat array but should be treated as
// /// a matrix with shape (n, k) (i.e. strides of length n).
// x: list<f64>,
// /// Scale on seasonality prior.
// sigmas: list<f64>,
// /// Scale on changepoints prior.
// /// Must be greater than 0.
// tau: f64,
// }
// The algorithm to use for optimization. One of: 'BFGS', 'LBFGS', 'Newton'.
typedef uint8_t augurs_prophet_wasmstan_types_algorithm_t;

// Use the Newton algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_NEWTON 0
// Use the Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_BFGS 1
// Use the Limited-memory BFGS (L-BFGS) algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_LBFGS 2

typedef struct {
  bool is_some;
  augurs_prophet_wasmstan_types_algorithm_t val;
} augurs_prophet_wasmstan_types_option_algorithm_t;

typedef struct {
  bool is_some;
  uint32_t val;
} prophet_wasmstan_option_u32_t;

typedef struct {
  bool is_some;
  double val;
} prophet_wasmstan_option_f64_t;

typedef struct {
  bool is_some;
  bool val;
} prophet_wasmstan_option_bool_t;

// Arguments for optimization.
typedef struct augurs_prophet_wasmstan_types_optimize_opts_t {
  // Algorithm to use.
  augurs_prophet_wasmstan_types_option_algorithm_t   algorithm;
  // The random seed to use for the optimization.
  prophet_wasmstan_option_u32_t   seed;
  // The chain id to advance the PRNG.
  prophet_wasmstan_option_u32_t   chain;
  // Line search step size for first iteration.
  prophet_wasmstan_option_f64_t   init_alpha;
  // Convergence tolerance on changes in objective function value.
  prophet_wasmstan_option_f64_t   tol_obj;
  // Convergence tolerance on relative changes in objective function value.
  prophet_wasmstan_option_f64_t   tol_rel_obj;
  // Convergence tolerance on the norm of the gradient.
  prophet_wasmstan_option_f64_t   tol_grad;
  // Convergence tolerance on the relative norm of the gradient.
  prophet_wasmstan_option_f64_t   tol_rel_grad;
  // Convergence tolerance on changes in parameter value.
  prophet_wasmstan_option_f64_t   tol_param;
  // Size of the history for LBFGS Hessian approximation. The value should
  // be less than the dimensionality of the parameter space. 5-10 usually
  // sufficient.
  prophet_wasmstan_option_u32_t   history_size;
  // Total number of iterations.
  prophet_wasmstan_option_u32_t   iter;
  // When `true`, use the Jacobian matrix to approximate the Hessian.
  // Default is `false`.
  prophet_wasmstan_option_bool_t   jacobian;
  // How frequently to update the log message, in number of iterations.
  prophet_wasmstan_option_u32_t   refresh;
} augurs_prophet_wasmstan_types_optimize_opts_t;

// Log lines produced during optimization.
typedef struct augurs_prophet_wasmstan_types_logs_t {
  // Debug log lines.
  prophet_wasmstan_string_t   debug;
  // Info log lines.
  prophet_wasmstan_string_t   info;
  // Warning log lines.
  prophet_wasmstan_string_t   warn;
  // Error log lines.
  prophet_wasmstan_string_t   error;
  // Fatal log lines.
  prophet_wasmstan_string_t   fatal;
} augurs_prophet_wasmstan_types_logs_t;

// The optimal parameter values found by optimization.
typedef struct augurs_prophet_wasmstan_types_optimized_params_t {
  // Base trend growth rate.
  double   k;
  // Trend offset.
  double   m;
  // Trend rate adjustments, length s in data.
  prophet_wasmstan_list_f64_t   delta;
  // Regressor coefficients, length k in data.
  prophet_wasmstan_list_f64_t   beta;
  // Observation noise.
  double   sigma_obs;
  // Transformed trend.
  prophet_wasmstan_list_f64_t   trend;
} augurs_prophet_wasmstan_types_optimized_params_t;

// The result of optimization.
// 
// This includes both the parameters and any logs produced by the
// process.
typedef struct augurs_prophet_wasmstan_types_optimize_output_t {
  // Logs produced by the optimization process.
  augurs_prophet_wasmstan_types_logs_t   logs;
  // The optimized parameters.
  augurs_prophet_wasmstan_types_optimized_params_t   params;
} augurs_prophet_wasmstan_types_optimize_output_t;

typedef augurs_prophet_wasmstan_types_inits_t exports_augurs_prophet_wasmstan_optimizer_inits_t;

typedef augurs_prophet_wasmstan_types_optimize_opts_t exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t;

typedef augurs_prophet_wasmstan_types_optimize_output_t exports_augurs_prophet_wasmstan_optimizer_optimize_output_t;

typedef struct {
  bool is_err;
  union {
    exports_augurs_prophet_wasmstan_optimizer_optimize_output_t ok;
    prophet_wasmstan_string_t err;
  } val;
} exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_t;

// Exported Functions from `augurs:prophet-wasmstan/optimizer`
bool exports_augurs_prophet_wasmstan_optimizer_optimize(exports_augurs_prophet_wasmstan_optimizer_inits_t *init, prophet_wasmstan_string_t *data, exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t *opts, exports_augurs_prophet_wasmstan_optimizer_optimize_output_t *ret, prophet_wasmstan_string_t *err);

// Helper Functions

void prophet_wasmstan_list_f64_free(prophet_wasmstan_list_f64_t *ptr);

void augurs_prophet_wasmstan_types_inits_free(augurs_prophet_wasmstan_types_inits_t *ptr);

void augurs_prophet_wasmstan_types_option_algorithm_free(augurs_prophet_wasmstan_types_option_algorithm_t *ptr);

void prophet_wasmstan_option_u32_free(prophet_wasmstan_option_u32_t *ptr);

void prophet_wasmstan_option_f64_free(prophet_wasmstan_option_f64_t *ptr);

void prophet_wasmstan_option_bool_free(prophet_wasmstan_option_bool_t *ptr);

void augurs_prophet_wasmstan_types_optimize_opts_free(augurs_prophet_wasmstan_types_optimize_opts_t *ptr);

void augurs_prophet_wasmstan_types_logs_free(augurs_prophet_wasmstan_types_logs_t *ptr);

void augurs_prophet_wasmstan_types_optimized_params_free(augurs_prophet_wasmstan_types_optimized_params_t *ptr);

void augurs_prophet_wasmstan_types_optimize_output_free(augurs_prophet_wasmstan_types_optimize_output_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_inits_free(exports_augurs_prophet_wasmstan_optimizer_inits_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_optimize_opts_free(exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_optimize_output_free(exports_augurs_prophet_wasmstan_optimizer_optimize_output_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_free(exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_t *ptr);

// Transfers ownership of `s` into the string `ret`
void prophet_wasmstan_string_set(prophet_wasmstan_string_t *ret, const char*s);

// Creates a copy of the input nul-terminate string `s` and
// stores it into the component model string `ret`.
void prophet_wasmstan_string_dup(prophet_wasmstan_string_t *ret, const char*s);

// Deallocates the string pointed to by `ret`, deallocating
// the memory behind the string.
void prophet_wasmstan_string_free(prophet_wasmstan_string_t *ret);

#ifdef __cplusplus
}
#endif
#endif

// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
#ifndef __BINDINGS_PROPHET_WASMSTAN_H
#define __BINDINGS_PROPHET_WASMSTAN_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

typedef struct prophet_wasmstan_string_t {
  uint8_t*ptr;
  size_t len;
} prophet_wasmstan_string_t;

typedef struct {
  double *ptr;
  size_t len;
} prophet_wasmstan_list_f64_t;

// The initial parameters for the optimization.
typedef struct augurs_prophet_wasmstan_types_inits_t {
  // Base trend growth rate.
  double   k;
  // Trend offset.
  double   m;
  // Trend rate adjustments, length s in data.
  prophet_wasmstan_list_f64_t   delta;
  // Regressor coefficients, length k in data.
  prophet_wasmstan_list_f64_t   beta;
  // Observation noise.
  double   sigma_obs;
} augurs_prophet_wasmstan_types_inits_t;

// The type of trend to use.
typedef uint8_t augurs_prophet_wasmstan_types_trend_indicator_t;

// Linear trend (default).
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_LINEAR 0
// 0
// Logistic trend.
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_LOGISTIC 1
// 1
// Flat trend.
#define AUGURS_PROPHET_WASMSTAN_TYPES_TREND_INDICATOR_FLAT 2

typedef struct {
  int32_t *ptr;
  size_t len;
} prophet_wasmstan_list_s32_t;

// Data for the Prophet model.
typedef struct augurs_prophet_wasmstan_types_data_t {
  // Number of time periods.
  // This is `T` in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  int32_t   n;
  // Time series, length n.
  prophet_wasmstan_list_f64_t   y;
  // Time, length n.
  prophet_wasmstan_list_f64_t   t;
  // Capacities for logistic trend, length n.
  prophet_wasmstan_list_f64_t   cap;
  // Number of changepoints.
  // This is 'S' in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  int32_t   s;
  // Times of trend changepoints, length s.
  prophet_wasmstan_list_f64_t   t_change;
  // The type of trend to use.
  augurs_prophet_wasmstan_types_trend_indicator_t   trend_indicator;
  // Number of regressors.
  // Must be greater than or equal to 1.
  // This is `K` in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  int32_t   k;
  // Indicator of additive features, length k.
  // This is `s_a` in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  prophet_wasmstan_list_s32_t   s_a;
  // Indicator of multiplicative features, length k.
  // This is `s_m` in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  prophet_wasmstan_list_s32_t   s_m;
  // Regressors.
  // This is `X` in the Prophet STAN model definition,
  // but WIT identifiers must be lower kebab-case.
  // This is passed as a flat array but should be treated as
  // a matrix with shape (n, k) (i.e. strides of length n).
  prophet_wasmstan_list_f64_t   x;
  // Scale on seasonality prior.
  prophet_wasmstan_list_f64_t   sigmas;
  // Scale on changepoints prior.
  // Must be greater than 0.
  double   tau;
} augurs_prophet_wasmstan_types_data_t;

// JSON representation of the Prophet data to pass to Stan.
// 
// This should be a string containing a JSONified `Data`.
typedef prophet_wasmstan_string_t augurs_prophet_wasmstan_types_data_json_t;

// The algorithm to use for optimization. One of: 'BFGS', 'LBFGS', 'Newton'.
typedef uint8_t augurs_prophet_wasmstan_types_algorithm_t;

// Use the Newton algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_NEWTON 0
// Use the Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_BFGS 1
// Use the Limited-memory BFGS (L-BFGS) algorithm.
#define AUGURS_PROPHET_WASMSTAN_TYPES_ALGORITHM_LBFGS 2

typedef struct {
  bool is_some;
  augurs_prophet_wasmstan_types_algorithm_t val;
} augurs_prophet_wasmstan_types_option_algorithm_t;

typedef struct {
  bool is_some;
  uint32_t val;
} prophet_wasmstan_option_u32_t;

typedef struct {
  bool is_some;
  double val;
} prophet_wasmstan_option_f64_t;

typedef struct {
  bool is_some;
  bool val;
} prophet_wasmstan_option_bool_t;

// Arguments for optimization.
typedef struct augurs_prophet_wasmstan_types_optimize_opts_t {
  // Algorithm to use.
  augurs_prophet_wasmstan_types_option_algorithm_t   algorithm;
  // The random seed to use for the optimization.
  prophet_wasmstan_option_u32_t   seed;
  // The chain id to advance the PRNG.
  prophet_wasmstan_option_u32_t   chain;
  // Line search step size for first iteration.
  prophet_wasmstan_option_f64_t   init_alpha;
  // Convergence tolerance on changes in objective function value.
  prophet_wasmstan_option_f64_t   tol_obj;
  // Convergence tolerance on relative changes in objective function value.
  prophet_wasmstan_option_f64_t   tol_rel_obj;
  // Convergence tolerance on the norm of the gradient.
  prophet_wasmstan_option_f64_t   tol_grad;
  // Convergence tolerance on the relative norm of the gradient.
  prophet_wasmstan_option_f64_t   tol_rel_grad;
  // Convergence tolerance on changes in parameter value.
  prophet_wasmstan_option_f64_t   tol_param;
  // Size of the history for LBFGS Hessian approximation. The value should
  // be less than the dimensionality of the parameter space. 5-10 usually
  // sufficient.
  prophet_wasmstan_option_u32_t   history_size;
  // Total number of iterations.
  prophet_wasmstan_option_u32_t   iter;
  // When `true`, use the Jacobian matrix to approximate the Hessian.
  // Default is `false`.
  prophet_wasmstan_option_bool_t   jacobian;
  // How frequently to update the log message, in number of iterations.
  prophet_wasmstan_option_u32_t   refresh;
} augurs_prophet_wasmstan_types_optimize_opts_t;

// Log lines produced during optimization.
typedef struct augurs_prophet_wasmstan_types_logs_t {
  // Debug log lines.
  prophet_wasmstan_string_t   debug;
  // Info log lines.
  prophet_wasmstan_string_t   info;
  // Warning log lines.
  prophet_wasmstan_string_t   warn;
  // Error log lines.
  prophet_wasmstan_string_t   error;
  // Fatal log lines.
  prophet_wasmstan_string_t   fatal;
} augurs_prophet_wasmstan_types_logs_t;

// The optimal parameter values found by optimization.
typedef struct augurs_prophet_wasmstan_types_optimized_params_t {
  // Base trend growth rate.
  double   k;
  // Trend offset.
  double   m;
  // Trend rate adjustments, length s in data.
  prophet_wasmstan_list_f64_t   delta;
  // Regressor coefficients, length k in data.
  prophet_wasmstan_list_f64_t   beta;
  // Observation noise.
  double   sigma_obs;
  // Transformed trend.
  prophet_wasmstan_list_f64_t   trend;
} augurs_prophet_wasmstan_types_optimized_params_t;

// The result of optimization.
// 
// This includes both the parameters and any logs produced by the
// process.
typedef struct augurs_prophet_wasmstan_types_optimize_output_t {
  // Logs produced by the optimization process.
  augurs_prophet_wasmstan_types_logs_t   logs;
  // The optimized parameters.
  augurs_prophet_wasmstan_types_optimized_params_t   params;
} augurs_prophet_wasmstan_types_optimize_output_t;

typedef augurs_prophet_wasmstan_types_inits_t exports_augurs_prophet_wasmstan_optimizer_inits_t;

typedef augurs_prophet_wasmstan_types_data_json_t exports_augurs_prophet_wasmstan_optimizer_data_json_t;

typedef augurs_prophet_wasmstan_types_optimize_opts_t exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t;

typedef augurs_prophet_wasmstan_types_optimize_output_t exports_augurs_prophet_wasmstan_optimizer_optimize_output_t;

typedef struct {
  bool is_err;
  union {
    exports_augurs_prophet_wasmstan_optimizer_optimize_output_t ok;
    prophet_wasmstan_string_t err;
  } val;
} exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_t;

// Exported Functions from `augurs:prophet-wasmstan/optimizer`
bool exports_augurs_prophet_wasmstan_optimizer_optimize(exports_augurs_prophet_wasmstan_optimizer_inits_t *init, exports_augurs_prophet_wasmstan_optimizer_data_json_t *data, exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t *opts, exports_augurs_prophet_wasmstan_optimizer_optimize_output_t *ret, prophet_wasmstan_string_t *err);

// Helper Functions

void prophet_wasmstan_list_f64_free(prophet_wasmstan_list_f64_t *ptr);

void augurs_prophet_wasmstan_types_inits_free(augurs_prophet_wasmstan_types_inits_t *ptr);

void prophet_wasmstan_list_s32_free(prophet_wasmstan_list_s32_t *ptr);

void augurs_prophet_wasmstan_types_data_free(augurs_prophet_wasmstan_types_data_t *ptr);

void augurs_prophet_wasmstan_types_data_json_free(augurs_prophet_wasmstan_types_data_json_t *ptr);

void augurs_prophet_wasmstan_types_option_algorithm_free(augurs_prophet_wasmstan_types_option_algorithm_t *ptr);

void prophet_wasmstan_option_u32_free(prophet_wasmstan_option_u32_t *ptr);

void prophet_wasmstan_option_f64_free(prophet_wasmstan_option_f64_t *ptr);

void prophet_wasmstan_option_bool_free(prophet_wasmstan_option_bool_t *ptr);

void augurs_prophet_wasmstan_types_optimize_opts_free(augurs_prophet_wasmstan_types_optimize_opts_t *ptr);

void augurs_prophet_wasmstan_types_logs_free(augurs_prophet_wasmstan_types_logs_t *ptr);

void augurs_prophet_wasmstan_types_optimized_params_free(augurs_prophet_wasmstan_types_optimized_params_t *ptr);

void augurs_prophet_wasmstan_types_optimize_output_free(augurs_prophet_wasmstan_types_optimize_output_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_inits_free(exports_augurs_prophet_wasmstan_optimizer_inits_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_data_json_free(exports_augurs_prophet_wasmstan_optimizer_data_json_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_optimize_opts_free(exports_augurs_prophet_wasmstan_optimizer_optimize_opts_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_optimize_output_free(exports_augurs_prophet_wasmstan_optimizer_optimize_output_t *ptr);

void exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_free(exports_augurs_prophet_wasmstan_optimizer_result_optimize_output_string_t *ptr);

// Transfers ownership of `s` into the string `ret`
void prophet_wasmstan_string_set(prophet_wasmstan_string_t *ret, const char*s);

// Creates a copy of the input nul-terminate string `s` and
// stores it into the component model string `ret`.
void prophet_wasmstan_string_dup(prophet_wasmstan_string_t *ret, const char*s);

// Deallocates the string pointed to by `ret`, deallocating
// the memory behind the string.
void prophet_wasmstan_string_free(prophet_wasmstan_string_t *ret);

#ifdef __cplusplus
}
#endif
#endif
